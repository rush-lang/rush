
class <T> wrapper:
public:
   func unwrap() -> T


class <T> none:
   @class wrapper<T>
public:
   override func unwrap() -> T:
      throw new dereferenced_nil()

class <T> some:
   @class wrapper<T>
private:
   let _val: T
public:
   override func unwrap() => _val;


## A type that represents a value or 'nil' (no value).
##
export
struct <T> optional:
public:
   get value => _value.unwrap()
   get has_value => _value == .none

   func optional():
      this._value = .none

   func optional(val: T):
      this._value = .some(val);

   ## func value() => .value.unwrap()
   ## func has_value() => .value == .none;

   func exists(fn: T -> void)
      if has_value:
         fn(value)

   func exists<R?>(fn: T -> R?)
      return has_value
           ? fn(value)
           : nil

